# Как я простые циклы искал
Проснулся я как-то ближе к вечеру и решил — всё пора, пора уже сделать новую фичу в моей [библиотеке](https://github.com/ivlevAstef/DITranquillity). А за одно и проверку графа на циклы починить и ускорить. К утреннему обеду сделал новую фичу, улучшил код, сделал представление графа в удобном виде, и дошёл до задачи нахождения всех [простых циклов](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2)) в графе. Потягивая чашку холодной воды, открыл гугл набрал "поиск всех простых циклов в графе" и увидел...
<cut/>

Увидел я не много... хотя было всеголишь 4 часа утра. Пару ссылок на алгоритмы ([ссылка1](http://codeforces.com/blog/entry/12141?locale=ru), [ссылка2](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83#:~:text=%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2%20%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83%20(%D0%B0%D0%BD%D0%B3%D0%BB.,%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D1%8F%D1%89%D0%B8%D0%B5%20%D0%B8%D0%B7%20%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D0%BE%D0%B9%20%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D1%8B%20%D1%80%D1%91%D0%B1%D1%80%D0%B0.)), и много намеком на то, что --пора спать-- циклов в графе может быть много, и в общем случае задача не решаемая. 

Но раз я решил, то даже [NP сложную задачу решу за P](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2_P_%D0%B8_NP) тем более я пью воду, а не кофе - а она не может резко закончится. Да и я то знал, что в рамках моей задачи найти все циклы должно быть возможным за маленькое время, без супер компьютеров - не тот порядок величин у меня. 

Немного отвлечемся от детектика, как я циклы искал, и поймем зачем мне это нужно.

## Что за библиотека?
Библиотека называется [DITranquillity](https://github.com/ivlevAstef/DITranquillity) написана на языке Swift, и её задача - [внедрять зависимости](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8). С задачей внедрения зависимостей библиотека справляется на ура, имеет возможности которые не умеют другие библиотеки на Swift, и делает это с хорошей скоростью.

## Но зачем мне взбрело проверять циклы в графе зависимостей?
Ради киллерфичи - если библиотека делает основной функционал на ура, то ищешь способы её улучшить и сделать лучше. А киллефича, это проверка графа зависимостей на правильность - это набор разных проверок, которые позволяют избежать проблем во время исполнениях, что экономит время разработки. И проверка на циклы выделяется отдельно среди всех проверок, так как эта операция занимает гораздо больше времени. И до недавнего времени некультурно больше времени.

О проблеме я знал давно, но понимал, что в том виде в каком сейчас хранится граф сделать быструю проверку сложно. Да и раз уж библиотека умеет проверять граф зависимостей, то сделать "Graph API" само напрашивается. "Graph API" - позволяет отдавать граф зависимостей для внешнего пользования, чтобы:
* Его проанализировать как-то на свой лад. Например, в своё время, для работы собрал автоматически все зависимости между нашими модулями, что помогло убрать лишние зависимости и ускорить сборку.
* Пока нет, но когда-нибудь будет - визуализация этого графа с помощью graphvis.
* Проверка графа на корректность.

Особенно ради второго - кто как, а мне нравится смотреть на эти ужасные картинки и понимать как же все плохо...
[Картинку с кучей вершин и связей]

## Исходные данные
Давайте посмотрим с чем предстоит работать:
* MacBook pro 2019, 2,6 GHz 6-Core i7, 32 Gb, Xcode 11.4, Swift 5.2
* Проект на языке Swift с 300к+ строчек кода (пустые строки и комментарии не в счёт)
* Более 900 вершин
* Более 2000 ребер
* Максимальная глубина зависимостей достигает 40
* Почти 7000 циклов

Все замеры делаются в debug режиме, не в release, так как использовать проверку графа будут только в дебаге.

До этой ночи, время проверки составляло 95 минут.
<spoiler title="Для не терпеливых">
После оптимизации время проверки уменьшилось до 3 секунд, то есть ускорение составило три порядка.
</spoiler>

# Этап 1. Представление графа
Возвращаемся к нашему детективу. Мой граф<s>не Монте Кристо</s>, он [ориентированный](https://ru.wikipedia.org/wiki/%D0%9E%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84#:~:text=%D0%9E%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%B3%D1%80%D0%B0%D1%84%20(%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE%20%D0%BE%D1%80%D0%B3%D1%80%D0%B0%D1%84)%20%E2%80%94,%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%BD%D0%B5%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%BC%20%D0%B8%D0%BB%D0%B8%20%D0%BD%D0%B5%D0%BE%D1%80%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%BC.).
Каждая вершина графа это компонент, ну или проще информация о классе. До появления Graph API все компоненты хранились в словаре, и каждый раз приходилось в него лазить, еще и ключ создавать. Что не очень быстро. Поэтому еще будучи в здравом уме, я понимал, что граф надо представить в удобном виде. 

Как человек не далекий от теории графов, я помнил только одно представление графа - Матрица смежности. Правда моё создание подсказывало, что есть и другие, и немного подряпряг память я вспомнил три варианта представления графа:
* Список вершин и список ребер - отдельно храним вершины отдельно храним ребра.
* [Матрица смежности](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8) - для каждой вершины храним информацию есть ли переход в другую вершину
* [Список смежности](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D1%81%D0%BC%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8) - для каждой вершины храним список переходов

Но прежде чем напрягать мозги, пальцы уже сделали своё дело, и пока я думал какой сейчас час, на экране уже успел появится код для создания графа в виде  матрицы смежности. Жалко конечно, но код написанный не введенье пришлось переписать - для моей задачи важнее как можно быстрее находить исходящие ребра, а вот входящие меня мало интерисуют. Да и память в наше время безгранична - чтобы её не сэкономить?

Переписав код, получилось что-то на подобии такого:
```
Graph:
	vertices: [Vertex]
	adjacencyList: [[Edge]]

Vertex:
	more information about vertex

Edge:
	toIndices: [Int]
	information about edge
```
Где Vertex информация о вершине, а Edge информация о переходе в том числе и индексы куда по данному ребру можно перейти. 
Обращаю внимание что ребро хранит переход не один в один, а один в много. Это сделано специально, чтобы обеспечить уникальность рёбер, что в случае зависимостей очень важно, так как два перехода на две вершины, и один переход на две вершины означает разные вещи.

# Этап 2. Наивный поиск в глубину
Из начала статьи все же помнят, что к этому моменту было уже 4 часа утра, а значит единственная идея как реализовать поиск всех простых циклов была та, что я нашел в гугле, да и мой учитель всегда говорил - "прежде чем оптимизировать, убедись, что это необходимо". Поэтому первым делом я написал обычный [поиск в глубину](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83):
```
func findAllCycles() -> [Cycle] {
  result: [Cycle] = []
  for index in vertices {
    result += findCycles(from: index)
  }

  return result
}

func findCycles(from index: Int) -> [Cycle] {
  result: [Cycle] = []
  dfs(startIndex: index, currentIndex: index, visitedIndices: [], result: &result)

  return result
}

func dfs(startIndex: Int,
         currentIndex: Int,
         // visitedIndices каждый раз копируется
         visitedIndices: Set<Int>,
         // result всегда один - это ссылка
         result: ref [Cycle]) {
  if currentIndex == startIndex && !visitedIndices.isEmpty {
    result.append(cycle)
    return
  }

  if visitedIndices.contains(currentIndex) {
    return
  }

  visitedIndices += [currentIndex]

  for toIndex in adjacencyList[currentIndex] {
    dfs(startIndex: startIndex, currentIndex: toIndex, visitedIndices: visitedIndices, result: &result)
  }
}
```
Запустил этот алгоритм, подождал 10 минут... и конечно же ушел спать - А то уже солнце появилось из-за верхушек зданий...

Пока спал думал - а почему так долго? Про размер графа я уже писал, но в чем проблема данного алгоритма? Судорожно вспоминая дебажные логи вспомнил, что для многих вершин количество вызовов функции dfs сотавляет миллион, а для некоторых по 30 миллионов раз. То есть в среднем 900 вершин * 1000000 = 900.000.000 вызовов функции dfs... 

Откуда такие бешенные цифры? Будь бы это обычный [лес](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2)#:~:text=%D0%9B%D0%B5%D1%81%20%E2%80%94%20%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D0%B5%D0%B2.,%D0%B2%D0%B5%D0%B4%D1%91%D1%82%20%D1%80%D0%BE%D0%B2%D0%BD%D0%BE%20%D0%BF%D0%BE%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9%20%D0%B4%D1%83%D0%B3%D0%B5).), то все бы работало быстро, но у нас же граф с циклами... ZZzzz...

# Этап 3. Наивная оптимизация
Проснулся я снова не по завету после обеда, и первым делом было не пойти в туалет, и уж точно не поесть, а посмотреть сколько же выполнялся мой алгоритм, а ну да всегото полтора часа... Ну ладно, я за ночь придумал как оптимизировать!
В первой реализации ищутся циклы только проходящие через указанную вершину, а все подциклы найденные при поиске основного цикла просто игнорируются. Возникает желание перестать их игнорировать - ведь тогда получается, что можно выкидывать из рассмотрения все вершины через которые мы уже прошли. Сделать это не так сложно, правда когда пальцы не попадают на клавиатуру чуть сложнее, но каких-то пол часа и готово:
```
func findAllCycles() -> [Cycle] {
  globalVisitedIndices: Set<Int> = []
  result: [Cycle] = []
  for index in vertices {
    if globalVisitedIndices.containts(index) {
      continue
    }
    result += findCycles(from: index, globalVisitedIndices: &globalVisitedIndices)
  }

  return result
}

func findCycles(from index: Int, globalVisitedIndices: ref Set<Int>) -> [Cycle] {
  result: [Cycle] = []
  dfs(currentIndex: index, visitedIndices: [], globalVisitedIndices, &globalVisitedIndices, result: &result)

  return result
}

func dfs(currentIndex: Int,
         // visitedIndices каждый раз копируется
         visitedIndices: Set<Int>,
         // globalVisitedIndices всегда один - это ссылка
         globalVisitedIndices: ref Set<Int>,
         // result всегда один - это ссылка
         result: ref [Cycle]) {

  if visitedIndices.contains(currentIndex) {
    // если visitedIndices упорядочен, то можно вырезать кусок тем самым получив информацию о цикле
    result.append(cycle)
    return
  }

  visitedIndices += [currentIndex]

  for toIndex in adjacencyList[currentIndex] {
    dfs(currentIndex: toIndex, visitedIndices: visitedIndices, globalVisitedIndices: &globalVisitedIndices, result: &result)
  }
}
```
Ну а дальше по заповедям программиста "Программист кушает, билд идёт" я ушел кушать... Ем я быстро, поэтому вернувшись через 10 минут, и увидев, что все еще нет результата я огорчился, и решил подумать в чем же проблема:
* Если у меня несколько раздельных больших циклов, то на каждый такой цикл тратиться уйму времени благо всего один раз.
* Многие циклы "дублируются" - нужно при добавление проверять уникальность, а это время на сравнение.

Интуиция мне подсказывала, что первый вариант был лучше. На самом деле он понятней для анализа, так как мы запоминаем циклы для конкретной вершины, а не для всего подрят.

# Этап 4. А что если отсекать листья из поиска
Проснуться я уже успел, а значит самое время для листочка и карандаша. Посмотрев на цифры, нарисовав картинки на листочке, стало понятно, что листья обходить не имеет смысла, и даже не листья, а целые ветки которые не имеют циклов. Смысл в них заходить, если мы ищем циклы? Вот их и будем отсекать. Пока это думал, руки уже все сделали, и даже нажали run... Ого вот это оптимизация - глазом моргнуть не успел, а уже все нашло... Ой, а чего циклов так мало то нашлось... Эх... А всё ясно проблема в том, что я <s>не налил себе стакан воды<s>. На самом деле проблема вот в этой строчке:
```
if visitedIndices.contains(currentIndex) {
```
Я решил, что в этом случае мы тоже наткнулись на лист, но это не верно. Давайте рассмотрим вот такой граф:
-----(картинка Graph.png)A->B, A->C, B->E, B->D, C->B, E->C, D->A
В этом графе есть подцикл B->E->C значит этот if выполнится. Теперь предположим, что вначале мы идем так:
A->B->E->C->B!. При таком проходе C, Е помечается как лист. После находим цикл A->B->D->A.
Но Цикл A->C->B->D->A будет упущен, так как вершина C помечена как лист.

Если это исправить и отбрасывать только листовые подветки, то количество вызовов dfs снижается, но не значительно.

# Этап 5. Делаем подготовку к поиску
Ладно еще целых пол дня впереди. Посмотрев картинки и различные дебажные логи, стало понятно, что есть ситуации где функция dfs вызывается 30миллионов раз, но находится всего 1-2 цикла. Такое возможно в случаях на подобии:
-----(картинка GraphBig.png)A -> B, B -> A, B -> C, C -> большой граф с кучей циклов в том числе и на C. 
Где "Big" это какой-то большой граф с кучей циклов, но не имеющий цикла на A.

И тут возникает идея! Для этого большого графа с циклами, можно заранее узнать, что он не имеет переходов на A или B, а значит сразу при переходе на C будет известно, что эту вершину не имеет смысла рассматривать, так как из нее нельзя попасть в A.

Как это узнать? Заранее, для каждой вершины запустить или поиск в глубину, или в ширину, и не посещать одну вершину дважды, и сохранить посещенные вершины. Такой поиск в худшем случае на полном графе займет N^2 времени, а на реальных данных намного меньше. 

Текст для статьи я писал гораздо дольше, чем код для реализации:
```
func findAllCycles() -> [Cycle] {
  reachableIndices: [Set<Int>] = findAllReachableIndices()
  result: [Cycle] = []
  for index in vertices {
    result += findCycles(from: index, reachableIndices: &reachableIndices)
  }

  return result
}

func findAllReachableIndices() -> [Set<Int>] {
  reachableIndices: [Set<Int>] = []
  for index in vertices {
    reachableIndices[index] = findAllReachableIndices(for: index)
  }
  return reachableIndices
}

func findAllReachableIndices(for startIndex: Int) -> Set<Int> {
  visited: Set<Int> = []
  stack: [Int] = [startIndex]
  while fromIndex = stack.popFirst() {
    visited.insert(fromIndex)

    for toIndex in adjacencyList[fromIndex] {
      if !visited.contains(toIndex) {
        stack.append(toIndex)
      }
    }
  }

  return visited
}

func findCycles(from index: Int, reachableIndices: ref [Set<Int>]) -> [Cycle] {
  result: [Cycle] = []
  dfs(startIndex: index, currentIndex: index, visitedIndices: [], reachableIndices: &reachableIndices, result: &result)

  return result
}

func dfs(startIndex: Int,
         currentIndex: Int,
         visitedIndices: Set<Int>,
         reachableIndices: ref [Set<Int>],
         result: ref [Cycle]) {
  if currentIndex == startIndex && !visitedIndices.isEmpty {
    result.append(cycle)
    return
  }

  if visitedIndices.contains(currentIndex) {
    return
  }

  if !reachableIndices[currentIndex].contains(startIndex) {
    return
  }

  visitedIndices += [currentIndex]

  for toIndex in adjacencyList[currentIndex] {
    dfs(startIndex: startIndex, currentIndex: toIndex, visitedIndices: visitedIndices, result: &result)
  }
}
```
Готовясь к худшему я запустил новую реализацию, и пошел смотреть в окно на ближайшее дерево, в 5 метрах - в даль смотреть говорят полезно. И вот счастье - код полностью исполнился за 15минут, что в 10 раз быстрее прошлого варианта. Порадовавшись мини победе, и порефачив код, я начал думать что же делать - такой результат меня не устраивал.

# Этап 6. Можно ли использовать прошлый результаты?
Все время пока я писал код, и пока спал, меня мучал вопрос - а можно ли как-то использовать результат прошлых вычислений. Ну ведь я уже нашел все циклы через вершину A, наверное что-то это да значит для других циклов.
Чтобы понять что это значит, мне понадобилось сделать три итерации каждая из которых была оптимальней предыдущей. 
Все началось с вопроса - "Зачем начинать поиск с новой вершины, если все исходящие ребра ведут в вершины которые или не содержат цикла, или это вершина через которую уже были построены все циклы?". Потом поток мыслей дошел до того что проверку можно делать рекурсивно. Это позволило уменьшить время до 5 минут.

И только выпив залпом весь стакан с водой, а он 250мл, я осознал, что эту проверку можно вставить прям внутри поиска в глубину:
```
func findAllCycles() -> [Cycle] {
  reachableIndices: [Set<Int>] = findAllReachableIndices()
  result: [Cycle] = []
  for index in vertices {
    result += findCycles(from: index, reachableIndices: &reachableIndices)
  }

  return result
}

func findAllReachableIndices() -> [Set<Int>] {
  reachableIndices: [Set<Int>] = []
  for index in vertices {
    reachableIndices[index] = findAllReachableIndices(for: index)
  }
  return reachableIndices
}

func findAllReachableIndices(for startIndex: Int) -> Set<Int> {
  visited: Set<Int> = []
  stack: [Int] = [startIndex]
  while fromIndex = stack.popFirst() {
    visited.insert(fromIndex)

    for toIndex in adjacencyList[fromIndex] {
      if !visited.contains(toIndex) {
        stack.append(toIndex)
      }
    }
  }

  return visited
}

func findCycles(from index: Int, reachableIndices: ref [Set<Int>]) -> [Cycle] {
  result: [Cycle] = []
  dfs(startIndex: index, currentIndex: index, visitedIndices: [], reachableIndices: &reachableIndices, result: &result)

  return result
}

func dfs(startIndex: Int,
         currentIndex: Int,
         visitedIndices: Set<Int>,
         reachableIndices: ref [Set<Int>],
         result: ref [Cycle]) {
  if currentIndex == startIndex && !visitedIndices.isEmpty {
    result.append(cycle)
    return
  }

  if visitedIndices.contains(currentIndex) {
    return
  }

  if currentIndex < startIndex || !reachableIndices[currentIndex].contains(startIndex) {
    return
  }

  visitedIndices += [currentIndex]

  for toIndex in adjacencyList[currentIndex] {
    dfs(startIndex: startIndex, currentIndex: toIndex, visitedIndices: visitedIndices, result: &result)
  }
}
```
Посмотрев на это простое решение, я нажал run, и был уже готов снова отойти от компьютера, как вдруг - все проверки прошли... 6 секунд? Не, не может быть... Но по дебажным логам все циклы были найдены.

Конечно я понимал подсознательно почему оно работает, и что я сделал. Постараюсь эту идею сформировать в тексте - Если уже найдены все циклы проходящие через вершину A, то при поиске циклов проходящие через любые другие вершины, рассматривать вершину A не имеет более смысла. Так-как уже найдены все циклы через A, а значит нельзя найти новых циклов через неё.

Такая проверка не только сильно ускоряет работу, но и полностью устраняет появление дублей, без необходимости их обрезать/сравнивать.
Что позволяет сэкономить время на способе хранения циклов - можно или вообще не хранить их или хранить в обычном массиве, а не множестве. Это экономит еще 5-10% времени исполнения.

# Этап 6. Профайл
Результат в 5-6 секунд меня уже устраивал, но хотелось еще быстрее, на улице еще солнце даже светит! Поэтому я открыл профайл. Я понимал что на языке Swift низкоуровневая оптимизация почти невозможна, но иногда находишь проблемы в неожиданных местах.
И какое-же было моё удивление когда я обнаружил, что половину времени из 6 секунд занимают логи библиотеки... Особенно с учетом, что я их выключил. Как говорится - ты видишь суслика? А он есть... У меня суслик оказался большим - на пол поля. Проблема была типичная - некоторое строковое выражение считалось всегда, не зависимо от необходимости писать его в логи. 

Запустив приложение и увидев 3 секунды, я уже хотел было остановиться, но меня мучало одно предчувствие в обходе в ширину. Я давно знал, что массивы у Apple сделаны так, что вставка в начало и в конец массива занимает константное время в силу кольцевой реализации внутри (извиняюсь, я не помню как правильно это называется). И так-же на языке Swift у массива есть интересная функция `popLast()`, но нет аналога для первого элемента. Но проще показать.
было (язык Swift):
```Swift
var visited: Set<Int> = []
var stack: [Int] = [startVertexIndex]
while let fromIndex = stack.first {
  stack.removeFirst()

  visited.insert(fromIndex)
  for toIndex in graph.adjacencyList[fromIndex].flatMap({ $0.toIndices }) {
    if !visited.contains(toIndex) {
      stack.append(toIndex)
    }
  }
}

return visited
```
cтало (язык Swift):
```Swift
var visited: Set<Int> = []
var stack: [Int] = [startVertexIndex]
while let fromIndex = stack.popLast() {
  visited.insert(fromIndex)
  for toIndex in graph.adjacencyList[fromIndex].flatMap({ $0.toIndices }) {
    if !visited.contains(toIndex) {
      stack.insert(toIndex, at: 0)
    }
  }
}

return visited
```
Вроде изменения не значительные, и кажется, что второй код должен работать медленнее - и на многих языках второй код будет работать медленнее, но на swift он быстрее на 5-10%.

# Итоги
А какие могут быть итоги? Цифры говорят сами за себя - было 95 минут, стало 2.5-3 секунды, да еще и добавилось новых проверок. 

Три секунды тоже выглядит не шустро, но не стоит забывать, что это на большом и не красивом графе зависимостей - такие днем с огнем не сыщешь в мобильной разработке.
Да и на другом проекте который больше похож на средний мобильный проект, время с 15 минут уменьшилось до менее секунды, при этом на более слабом железе.

Ну а появлению статьи благодарим гугл - который не захотел мне помогать, и я придумывал все из головы, хоть и понимаю что Америку я не открыл.

# Немного рекламы и Планы
Кому понравилась статья, или не понравилась, пожалуйста зайдите на страничку [библиотеки](https://github.com/ivlevAstef/DITranquillity) и поставьте ей звездочку.

Я каждый раз озвучиваю планы по развитию, каждый раз говорю "скоро" и всегда скоро оказывается когда-нибудь. Поэтому сроков называть не буду, но когда-нибудь это появится:
* Конвертация графа зависимостей в формат для graphvis - а он в свою очередь позволит просматривать графы визуально.
* Оптимизация основного функционала библиотеки - к сожалению с появлением большого количества новых функций, моя библиотека хоть и осталось быстрой, но теперь она не сверх быстрая, а на уровне других библиотек.
* Переход на проверку графа и поиск проблем во время компиляции, а не при запуске приложения.


P.S. Если отключить 5 этап полностью, это который добавление доп. действие перед началом поиска, то скорость работы понизится в 1.5 раза - до 4.5 секунд. То есть в этой операции даже после всех других оптимизаций есть толк.

P.P.S. Некоторые факты из статьи выдуманные, для придания красоты картины. Но я на самом деле пью только чистую воду, и не люблю чай/кофе/алкоголь.
